import asyncio
import logging
import time
import typing

import httpx
from asgiref.sync import sync_to_async
from django.core.management.base import BaseCommand, CommandError, CommandParser
from django.db import transaction
from django.utils import timezone

from django_pokeapi.apps.pokeapi.ipc import ipc_operations
from django_pokeapi.apps.pokeapi.ipc.async_pokeapi_client import AsyncPokeAPIClient
from django_pokeapi.apps.pokeapi.ipc.dto.abilities import Ability
from django_pokeapi.apps.pokeapi.ipc.dto.pokemon import PokemonDTO
from django_pokeapi.apps.pokeapi.ipc.dto.types import PokemonType

_log = logging.getLogger(__name__)


class Command(BaseCommand):
    """Management command to update database with PokeAPI data using async fetching."""

    help = "Update database with Pokemon data from PokeAPI (optimized with async)"

    def add_arguments(self, parser: CommandParser) -> None:
        """Add command line arguments."""
        parser.add_argument(
            "--types-only", action="store_true", help="Only update Pokemon types"
        )
        parser.add_argument(
            "--abilities-only",
            action="store_true",
            help="Only update Pokemon abilities",
        )
        parser.add_argument(
            "--pokemon-only", action="store_true", help="Only update Pokemon data"
        )
        parser.add_argument(
            "--ignore-errors",
            action="store_true",
            help="Continue processing even if some data fails to fetch",
        )

    @transaction.atomic
    def handle(self, *args: typing.Any, **options: typing.Any) -> None:
        """Execute the command."""
        # Suppress httpx HTTP request logs during this command execution
        httpx_logger = logging.getLogger("httpx")
        original_level = httpx_logger.level
        httpx_logger.setLevel(logging.WARNING)

        try:
            start_time = timezone.now()
            formatted_start_time = start_time.strftime("%d.%m.%Y %H:%M:%S")
            _log.info(
                "Starting optimized PokeAPI data update at %s", formatted_start_time
            )

            try:
                asyncio.run(self._populate_db(options))
            except Exception as e:
                _log.error("Unexpected error occurred!", exc_info=e)
                raise CommandError(f"Error updating database: {str(e)}") from e

            end_time = timezone.now()
            duration = end_time - start_time
            formatted_end_time = end_time.strftime("%d.%m.%Y %H:%M:%S")

            _log.info(
                "Database update completed at %s in %d seconds",
                formatted_end_time,
                int(duration.total_seconds()),
            )
        finally:
            # Restore original httpx logging level
            httpx_logger.setLevel(original_level)

    async def _populate_db(self, options: dict) -> None:
        """Asynchronously fetch data and synchronously save to database.

        Args:
            options: Command options
        """
        # Create and configure async client with improved settings
        # Note: HTTP request logs are automatically generated by httpx library
        # when logging level is set to INFO or DEBUG (visible as "[INFO][httpx]: HTTP Request...")
        async_client = httpx.AsyncClient(
            timeout=httpx.Timeout(
                60.0, connect=15.0, read=45.0, pool=10.0
            ),  # Generous timeouts
            headers={
                "User-Agent": (
                    "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 "
                    "(KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36"
                )
            },
            limits=httpx.Limits(
                max_keepalive_connections=100, max_connections=1500
            ),  # Support many concurrent connections
            follow_redirects=True,
        )

        try:
            client = AsyncPokeAPIClient(async_client)

            _log.info("Phase 1: Fetching data from PokeAPI...")
            fetch_start_time = time.time()

            if options["types_only"]:
                types_data = await self._fetch_types_async(client, options)
                abilities_data = []
                pokemon_data = []
            elif options["abilities_only"]:
                types_data = []
                abilities_data = await self._fetch_abilities_async(client, options)
                pokemon_data = []
            elif options["pokemon_only"]:
                types_data = []
                abilities_data = []
                pokemon_data = await self._fetch_pokemon_async(client, options)
            else:
                # Fetch all data concurrently
                types_data, abilities_data, pokemon_data = await asyncio.gather(
                    self._fetch_types_async(client, options),
                    self._fetch_abilities_async(client, options),
                    self._fetch_pokemon_async(client, options),
                )

            fetch_duration = time.time() - fetch_start_time

            _log.info(
                "Phase 1 completed: Fetched items in %d seconds", int(fetch_duration)
            )

            _log.info("Phase 2: Saving data to database...")
            db_start_time = time.time()

            # Report the actual counts of successfully fetched data
            _log.info(
                "Successfully fetched: %d types, %d abilities, %d Pokemon",
                len(types_data),
                len(abilities_data),
                len(pokemon_data),
            )

            await sync_to_async(ipc_operations.bulk_save_all_data)(
                types_data, abilities_data, pokemon_data
            )
            db_duration = time.time() - db_start_time

            _log.info(
                "Phase 2 completed: Saved items to database in %d seconds",
                int(db_duration),
            )

        finally:
            await async_client.aclose()

    async def _fetch_types_async(
        self, client: AsyncPokeAPIClient, options: dict
    ) -> list[PokemonType]:
        """Asynchronously fetch all Pokemon types data.

        Args:
            client: Async PokeAPI client instance
            options: Command options

        Returns:
            List of fetched PokemonType data
        """
        _log.info("Fetching Pokemon types asynchronously...")

        # Get all types list
        types_response = await client.get_all_types()
        total_types = len(types_response.results)
        _log.info("Found %d types to process", total_types)

        # Extract type IDs and fetch all at once
        type_ids = [
            int(type_ref.url.split("/")[-2]) for type_ref in types_response.results
        ]

        _log.info("Fetching all %d types...", len(type_ids))
        all_types_data = await client.get_multiple_types(type_ids)

        _log.info("Successfully fetched %d types", len(all_types_data))
        return all_types_data

    async def _fetch_abilities_async(
        self, client: AsyncPokeAPIClient, options: dict
    ) -> list[Ability]:
        """Asynchronously fetch all Pokemon abilities data.

        Args:
            client: Async PokeAPI client instance
            options: Command options

        Returns:
            List of fetched Ability data
        """
        _log.info("Fetching Pokemon abilities asynchronously...")

        # Get all abilities list
        abilities_response = await client.get_all_abilities()
        total_abilities = len(abilities_response.results)
        _log.info("Found %d abilities to process", total_abilities)

        # Extract ability IDs and fetch all at once
        ability_ids = [
            int(ability_ref.url.split("/")[-2])
            for ability_ref in abilities_response.results
        ]

        _log.info("Fetching all %d abilities...", len(ability_ids))
        all_abilities_data = await client.get_multiple_abilities(ability_ids)

        _log.info("Successfully fetched %d abilities", len(all_abilities_data))
        return all_abilities_data

    async def _fetch_pokemon_async(
        self, client: AsyncPokeAPIClient, options: dict
    ) -> list[PokemonDTO]:
        """Asynchronously fetch all Pokemon data.

        Args:
            client: Async PokeAPI client instance
            options: Command options

        Returns:
            List of fetched Pokemon data
        """
        _log.info("Fetching Pokemon data asynchronously...")

        # Get Pokemon list
        pokemon_response = await client.get_all_pokemon()
        total_pokemon = len(pokemon_response.results)
        _log.info("Found %d Pokemon to process", total_pokemon)

        # Extract Pokemon IDs and fetch all at once
        pokemon_ids = [
            int(pokemon_ref.url.split("/")[-2])
            for pokemon_ref in pokemon_response.results
        ]

        _log.info("Fetching all %d Pokemon...", len(pokemon_ids))
        all_pokemon_data = await client.get_multiple_pokemon(pokemon_ids)

        _log.info("Successfully fetched %d Pokemon", len(all_pokemon_data))
        return all_pokemon_data
